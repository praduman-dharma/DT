In **Magento 2**, **interceptors** and **plugins** are tightly related concepts. Here's a clear explanation to understand them:

---

### 🔶 What are Interceptors?

An **interceptor** is a **generated class** in Magento 2 that is automatically created to enable **plugins** to wrap around original class methods. You don't write interceptors manually—Magento's code generation system creates them when needed.

**Purpose of interceptors**:

* Allow plugins to run **before**, **after**, or **around** a method of a class.
* Provide a non-intrusive way to **modify or extend core functionality** without rewriting the original class.

---

### 🔶 What is a Plugin?

A **plugin** is a class you write that **intercepts method calls** on another class to:

* Modify input (`before` plugin)
* Modify output (`after` plugin)
* Completely override behavior (`around` plugin)

Plugins work **via interceptors** under the hood.

#### Example:

If you want to intercept the `getName()` method of `\Magento\Catalog\Model\Product`, you write a plugin like this:

```php
namespace Vendor\Module\Plugin;

class ProductPlugin
{
    public function afterGetName(\Magento\Catalog\Model\Product $subject, $result)
    {
        return $result . ' (Modified)';
    }
}
```

---

### 🔄 Relationship Between Plugin and Interceptor

| Concept         | Description                                                                                    |
| --------------- | ---------------------------------------------------------------------------------------------- |
| **Plugin**      | The class you define to add behavior to Magento's core or custom methods.                      |
| **Interceptor** | A class **auto-generated** by Magento that wraps the original class and executes plugin logic. |

> The plugin is the logic, and the interceptor is the mechanism that executes it.

---

### 🧠 Analogy

* Think of the **original class** as a TV.
* **Plugin** is like a remote control that can adjust volume or mute the TV.
* **Interceptor** is the internal wiring in the TV that listens to the remote and applies the changes.

---

### 🧩 Types of Plugin Methods

| Type     | Signature                                                 | Description                                             |
| -------- | --------------------------------------------------------- | ------------------------------------------------------- |
| `before` | `beforeMethodName($subject, ...$args)`                    | Modifies input parameters                               |
| `after`  | `afterMethodName($subject, $result)`                      | Modifies return result                                  |
| `around` | `aroundMethodName($subject, callable $proceed, ...$args)` | Wraps entire method logic, and can skip original method |

---

### ✅ Summary Table

| Feature                | Interceptor                            | Plugin                                   |
| ---------------------- | -------------------------------------- | ---------------------------------------- |
| Who writes it          | Auto-generated by Magento              | Written by developers                    |
| Purpose                | Executes plugin code on target methods | Contains logic to extend/modify behavior |
| Can modify logic?      | No, only delegates to plugins          | Yes (before/after/around methods)        |
| Exists without plugin? | No                                     | No plugin → no interceptor               |

---

Let's walk through the **full plugin execution flow in Magento 2**, including:

1. How a plugin is triggered
2. The **role of interceptors**
3. The **execution order** of `before`, `around`, and `after` methods

---

### 🔄 Magento Plugin Execution Flow

Let's say you call a method like this in Magento:

```php
$product->getName();
```

Assume plugins are declared on `\Magento\Catalog\Model\Product::getName`.

#### Here's what happens step-by-step:

1. Magento checks if the class (`Product`) has any plugins.
2. If yes, it creates a **generated "interceptor class"** (e.g., `\Magento\Catalog\Model\Product\Interceptor`).
3. All calls to `getName()` are **routed to the interceptor**, not the real `Product` class.
4. The **interceptor** manages execution of all plugin methods:

   * `beforeGetName()`
   * `aroundGetName()`
   * `afterGetName()`
5. Then it finally calls the real `getName()` method if no plugin stopped it.

---

### 🔁 Execution Order of Plugin Methods

#### ✅ Plugin priority:

1. `before` plugins — run **before** the original method.
2. `around` plugins — **wrap** the original method (and can prevent it from running).
3. `after` plugins — run **after** the method returns.

---

### ⚙️ Detailed Execution Flow:

Assume a method `foo()` and you have plugins registered like this:

```php
class PluginA {
    public function beforeFoo($subject, $arg) { ... }
    public function aroundFoo($subject, callable $proceed, $arg) { ... }
    public function afterFoo($subject, $result) { ... }
}
```

The execution order will be:

```
1. beforeFoo()
2. aroundFoo() {
      → optionally call $proceed() {
             → real foo() method is executed
        }
   }
3. afterFoo()
```

#### 🔍 Note:

* If there are **multiple plugins**, Magento executes:

  * All `before` methods in **declared order**
  * All `around` methods in **nested (onion-like) order**, outermost to innermost
  * All `after` methods in **reverse order**

---

### 🧅 Around Plugin Nesting Example (Multiple Plugins)

Given:

* PluginA (sortOrder: 10)
* PluginB (sortOrder: 20)

Then the call stack would look like:

```
PluginA.around -> PluginB.around -> realMethod() -> PluginB.after -> PluginA.after
```

---

### 🔒 Can `around` skip original method?

Yes. If `aroundFoo()` does **not call `$proceed()`**, the **original method (and any after plugin)** is never called.

Example:

```php
public function aroundGetName($subject, callable $proceed)
{
    return 'Intercepted name'; // Original method is skipped
}
```

---

### 🔧 Interceptor Example (Generated)

Magento generates something like this in `generated/code/Magento/Catalog/Model/Product/Interceptor.php`:

```php
public function getName()
{
    $pluginInfo = $this->pluginList->getNext($this->getSubjectType(), 'getName');
    if (!$pluginInfo) {
        return parent::getName();
    }

    return $this->___callPlugins('getName', func_get_args(), $pluginInfo);
}
```

The `___callPlugins()` method will:

* Run `before` plugins
* Wrap with `around` if any
* Call original if `around` allows
* Run `after` plugins

---

### ✅ Summary

| Plugin Type | When It Runs    | Can Modify   | Can Stop Method? |
| ----------- | --------------- | ------------ | ---------------- |
| `before`    | Before original | Yes (input)  | No               |
| `around`    | Wraps original  | Yes (full)   | Yes              |
| `after`     | After original  | Yes (output) | No               |

---
